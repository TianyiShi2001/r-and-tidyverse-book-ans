[
["index.html", "R与tidyverse——数据分析入门 欢迎", " R与tidyverse——数据分析入门 石天熠 2019-07-01 欢迎 简介 本书为R(R Core Team 2019)和tidyverse(Wickham 2017)的入门向教程。教学视频在b站（）。 使用说明 左上角的菜单可以选择收起/展开目录，搜索，和外观，字体调整。 如果你对某一段文字有修改意见，可以选择那段文字，并通过Hypothesis留言（选择“annotate”）。右上角可以展开显示公开的留言。 如果你熟悉Bookdown和Github，可以在此提交pull request. Bibiolography "],
["intro-and-installation.html", "Chapter 1 R和RStudio介绍和安装教程 1.1 什么是R 1.2 安装R和RStudio 1.3 为什么使用R，R与其他统计软件的比较1", " Chapter 1 R和RStudio介绍和安装教程 1.1 什么是R R(R Core Team 2019)包含R语言和一个有着强大的统计分析及作图功能的软件系统，由新西兰奥克兰大学的Ross Ihaka和Robert Gentleman共同开发。R语言虽然看起来只能做统计，实际上它麻雀虽小，五脏俱全，编程语言该有的特性它基本都有（甚至支持OPP）。 安装了R之后，你可以在其自带的“R”软件中（也可以直接在命令行使用），但是那个软件界面比较简单，需要记住一些命令来执行“查看当前存储的数据”，“导出jpg格式的图像”等操作，对新手不太友好。因此我们使用RStudio. RStudio(RStudio Team 2015)是R语言官方的IDE（集成开发环境），它的一系列功能使得编辑，整理和管理R代码和项目方便很多。 了解R的优势，请看第1.3节 1.2 安装R和RStudio 1.2.1 安装R https://cran.r-project.org 前往CRAN，根据自己的操作系统（Linux，MacOS或Windows）选择下载安装R. (Linux用户亦可参考此处) 1.2.2 安装RStudio https://www.rstudio.com/products/rstudio/download/ 前往RStudio下载页，选择最左边免费的开源版本，然后选择对应自己的操作系统的版本，下载并安装。 1.3 为什么使用R，R与其他统计软件的比较1 （这一小节不影响R的学习进度，可以直接跳过到下一章） SAS，SPSS，Prism，R和Python是数据分析和科研作图常用的软件。 SAS，SPSS和Prism都是收费的，而且不便宜。比如SAS第一年需要10000多美元，随后每年要缴纳几千美元的年费。 R比SAS功能更强大。所有SAS中的功能，都能在R中实现，而很多R中的功能无法在SAS中实现2。 R和Python（NumPy和SciPy）是开源、免费的。在数据分析的应用中，R比Python历史更悠久，因此积攒了很多很棒的packages（包）。一般来说，python的强项是数据挖掘，而R的强项是数据分析，它们都是强大的工具。不用担心需要在二者之中做选择，因为rpy, reticulate等packages可以让你在python中使用R，在R中使用python，详情请见第9章。无论你是数据分析零基础，还是有python数据分析的经验，都能从本书中获益。 至于Excel，它的定位原本就是办公（而不是学术）软件，用作数据收集和初步整理是可以的，但是做不了严谨的数据分析和大数据，功能也非常局限。有五分之一的使用了Excel的遗传学论文，数据都出现了偏差(Ziemann, Eren, and El-Osta 2016)。 R是GNU计划的一部分，因此R是一个自由软件 (Libre software)。你可以 在GNU官网了解更多。 此外，R可以完美地在Linux中运行。 Bibiolography "],
["getting-help.html", "Chapter 2 获取资源与帮助（重要！） 2.1 论坛类（解答实际操作中的问题） 2.2 Reference类（查找特定的function/package的用法，就像查字典一样） 2.3 教程和书籍类（用来系统地学习） 2.4 速查表 (Cheat sheets)（用来贴墙上）", " Chapter 2 获取资源与帮助（重要！） 这本书可以帮助你快速学会R和tidyverse的最常用和最重要的操作，但这仅仅是冰山一角。当你在做自己的研究的时候，会用到很多这本书中没有讲到的方法，因此学会获取资源和帮助是很重要的。以下列举几个常用的获取R的帮助的网站/方法： 2.1 论坛类（解答实际操作中的问题） 爆栈网 (StackOverflow)是著名计算机技术问答网站（如果你有其他的编程语言基础，一定对它不陌生）。查找问题的时候加上[R]，这样搜索结果就都是与R相关的了（为了进一步缩小搜索范围，可以加上其他的tag，比如[ggplot], [dplyr])。注意，提问和回答的时候话语尽量精简，不要在任何地方出现与问题无关的话（包括客套话如“谢谢”），了解更多请查看其新手向导。 由谢益辉大佬在2006年（竟然比爆栈网更早！）创建的“统计之都”论坛，是做的最好的一个面向R的中文论坛（但是客观地来说活跃度还是没爆栈网高）同样不要忘记读新手指引。 2.2 Reference类（查找特定的function/package的用法，就像查字典一样） 直接在R console中执行?+函数名称，比如?t.test RDocumentation上有基础R语言和来自CRAN，GitHub和Bioconductor上的近18000个packages的所有的函数的说明和使用例。 有些packages会在官网/github仓库提供使用说明，比如tidyverse 有些packages会提供vignettes，它们类似于使用指南，相比于函数的documentation更为详细且更易读。vignette()（无参数）以查看全部可用vignettes. 你可以试试vignette(&quot;Sweave&quot;)， 它是用LaTeX排版的，很漂亮。 2.3 教程和书籍类（用来系统地学习） R的官方Manuals. 其中新手只需要看An Introduction to R，随后选看R Language Definition即可。部分由丁国徽翻译成中文（点击量其实并不高……要想把握前沿信息还是需要阅读英语的能力的）。 R for Data Science by Garrett Grolemund &amp; Hadley Wickham. tidyverse的作者写的一本书，较为详细地介绍了tidyverse的用法以及一些更高深的关于编程的内容。（练习题答案） RStudio Resources是RStudio的资源区，有关于R和RStudio的高质量教程，还可以下载很多方便实用的Cheat Sheet. The R Book by Michael J. Crawley R的官方FAQ（在左侧菜单栏中找到“FAQ”） 存储在CRAN上的中文FAQ（注意这不是英文FAQ的翻译，而是一本独立的R入门教程） Advanced R by Hadley Wickham及其练习题答案。 2.4 速查表 (Cheat sheets)（用来贴墙上） R Reference Card 2.0 by Mayy Baggott &amp; Tom Short以及其第一版的中文翻译 RStudio Cheat Sheets包含了RStudio IDE和常用packages的cheat sheets。2019年版的合集在这里。 "],
["ch2.html", "Chapter 3 RStudio界面介绍，基本操作，和创建新项目 3.1 界面 3.2 基本操作", " Chapter 3 RStudio界面介绍，基本操作，和创建新项目 3.1 界面 3.1.1 概览 3.1.2 左下角：Console（控制台） Console是执行代码的地方。试试在里面输入1 + 1并按回车以执行。 3.1.3 左上角：Source（源） Source是写代码的地方。请看第3.2.2节。 这个位置也是用来查看文件和数据的地方。试试在console中执行View(airquality)或library(help = &quot;stats&quot;). 3.1.4 右上角：Environment（环境）， Environment 是一个列表，显示了所有当前工作环境中所有的变量（“values”和“data”）和自定义的函数（functions）。 History（历史）和 Connections（连接）不太常使用。 3.1.5 右下角：Plots（绘图），Help（帮助），Files（文件）和Packages（包） Plots是预览图像的区域。试试在console中执行hist(rnorm(10000)). Help是查看帮助文件的区域。试试在console中执行?hist或?norm. Files是查看文件的区域，默认显示工作目录 (working directory)。 Packages是安装/查看/更新packages（包）的区域。详情请看第4章。 3.2 基本操作 3.2.1 执行代码 试着在console里输入1 + 1，并按回车以执行。你的console会显示： &gt; 1 + 1 [1] 2 其中2是计算结果， [1]是索引，在第5.1.2节有解释。&gt; 1 + 1是input，[1] 2是output. 还是用1 + 1举例，在本书中，对于input和output的展示格式是这样的： 1+1 ## [1] 2 注意input中的&gt;被省略了，这意味着你可以直接把代码从本书复制到你的console并按回车执行（因为console本身自带了&gt;)，类似地，你从其他各种网站上找到的说明书，教程和论坛帖子中看到的R代码，大多数也都是这种形式呈现，便于复制粘贴。 再来一个例子，试着在console里输入（或者复制）以下代码并执行： attach(airquality) plot(Wind, Ozone, main = &quot;Ozone and Wind in New York City&quot;, pch = 20) model &lt;- lm(Ozone ~ Wind, airquality) abline(model, lwd = 2) 可以看到，在plots区，生成了一副漂亮的图。（先别在意每行代码具体的作用，在之后的章节我会一一讲述） 这时，把RStudio关掉，再重新启动，你会发现你的图没了。因此我们需要记录和管理代码。 3.2.2 记录和管理代码 初学者经常会在console里写代码，或者从别处复制代码，并执行。这对于一次性的计算（比如写统计学作业时用R来算线性回归的参数）很方便，但是如果你想保存你的工作，你需要把它们记录在R script文件里。如果你的工作比较复杂，比如有一个excel表格作为数据源，然后在R中用不同的方法分析，导出图表，这时候你会希望这些文件都集中在一起。你可以使用R Project来管理它们。 3.2.2.1 创建R Project 左上角File &gt; New Project 点选New Directory &gt; New Project 输入名称和目录并Create Project 3.2.2.2 使用R Project 在创建R project的文件夹中打开.Rproj文件。或者，RStudio启动的时候默认会使用上一次所使用的R project. 随后，你在RStudio中做的所有工作都会被保存到.Rproj所在的这个文件夹（正规的说法是“工作目录” (working directory)）。比如，在console中执行： pdf(&quot;normalDistrubution.pdf&quot;) curve(dnorm(x),-5,5) dev.off() 一个正态分布的图像便以pdf格式保存在了工作目录。你可以在系统的文件管理器中，或是在RStudio右下角File面板中找到。 3.2.3 写/保存/运行R script 在console中运行代码，代码得不到保存。代码需保存在R script文件（后缀为.R）里。 Ctrl+Shift+N（Mac是command+shift+N）以创建新R script. 然后就可以写R script. 合理使用换行可以使你的代码更易读。#是注释符号。每行第一个#以及之后的内容不会被执行。之前的例子，可以写成这样： # 读取数据 attach(airquality) # 绘图 plot(Wind, Ozone, # x轴和y轴 main = &quot;Ozone and Wind in New York City&quot;, # 标题 pch = 20) # 使用实心圆点 model &lt;- lm(Ozone ~ Wind, airquality) # 线性回归模型 abline(model, lwd = 2) # 回归线 Ctrl+Enter (command+return)以执行一“句”代码（比如上面的例子中，从plot(Wind...到pch = 20)有三行，但是它是一“句”）。 Ctrl+Shift+Enter (command+shift+return)以从头到尾执行所有代码。 试试复制并执行以上代码吧。 Ctrl+S (command+S)以保存R script. 保存后会在工作目录找到你新保存的.R文件。重新启动RStudio的时候，便可以打开对应的R script文件以重复/继续之前的工作。 3.2.4 关于换行 Console 中每个命令开头的&gt;叫做prompt（命令提示符），当它出现在你所编辑的那一行的开头时，按下回车的时候那行的命令才会被执行。有时候它会消失，这时候按esc可以将其恢复。 prompt消失的主要原因是你的代码没有写完，比如括号不完整： &gt; 2+(3+4 这时你按回车，它会显示： &gt; 2+(3+4 + +号是在提示代码没写完整。这时你把括号补上再按回车： &gt; 2+(3+4 + ) [1] 9 便可以完成计算。 这意味着我们可以把一条很长的命令分成很多行。比如我们可以写这样的代码（在R script编辑器中！） if(TRUE){ print(2) } else{ print(3) } 然后Ctrl+Enter执行。你会发现在console中，从第二行开始每行开头都有一个+号。 "],
["packages.html", "Chapter 4 安装和使用packages (包) 4.1 Package是什么，为什么使用它们？ 4.2 如何安装packages 4.3 如何使用packages 4.4 其它", " Chapter 4 安装和使用packages (包) 4.1 Package是什么，为什么使用它们？ Package是别人写好的在R中运行的程序（以及附带的数据和文档），你可以免费安装和使用它们。 Packages可以增加在基础R语言中没有的功能，可以精简你代码的语句，或是提升使用体验。比如有个叫做tikzDevice的package可以将R中的图表导出成tikz语法的矢量图，方便在LaTeX中使用。本书的编写和排版也是使用R中的一个叫做bookdown的package完成的（真的超棒）. 这个课程主要是学习tidyverse这个package， 4.2 如何安装packages 首先我们安装tidyverse（很重要，本书接下来的部分都要使用这个package）： install.packages(&quot;tidyverse&quot;) 在console中运行以上代码，R就会从CRAN中下载tidyverse并安装到你电脑上的默认位置。因此安装packages需要网络连接。 如果想安装多个packages，你可以一行一行地安装，或是把多个packages的名字合成一列，同时安装，比如： install.packages(c(&quot;nycflights13&quot;, &quot;gapminder&quot;, &quot;Lahman&quot;) 它其中包含一系列小 4.3 如何使用packages 安装packages后，有两种方法使用它们。以tidyverse为例： library(&#39;tidyverse&#39;) 或 require(&#39;tidyverse&#39;) 两者的效果很大程度上都是一样的，都可以用来读取单个package。它们的不同，以及如何通过一行指令读取多个packages，请参看第4.4.1节。 每次重启R的时候，上一次使用的packages都会被清空，所以需要重新读取。因此我们要在R script里面记录此script需要使用的packages（这个特性可以帮助你养成好习惯：当你把你的代码分享给别人的时候，要保证在别人的电脑上也能正常运行，就必须要指明要使用哪些packages） 4.4 其它 这小节是一些不重要的内容，因此可酌情跳到下一章（第5章。 4.4.1 library()和require的区别；如何使用一行指令读取多个packages require()会返回一个逻辑值。如果package读取成功，会返回TRUE，反之则返回FALSE. library()如果读取试图读取不存在的package，会直接造成错误(error)，而require()不会造成错误，只会产生一个警告(warning). 这意味着require()可以用来同时读取多个packages： lapply(c(&quot;dplyr&quot;,&quot;ggplot2&quot;), require, character.only = TRUE) ## Loading required package: dplyr ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union ## Loading required package: ggplot2 ## [[1]] ## [1] TRUE ## ## [[2]] ## [1] TRUE 或者更精简一点， lapply(c(&quot;dplyr&quot;,&quot;ggplot2&quot;), require, c = T) ## [[1]] ## [1] TRUE ## ## [[2]] ## [1] TRUE "],
["vectors-logicals-and-functions.html", "Chapter 5 向量，逻辑，循环和函数 5.1 向量的概念，操作和优越性 5.2 数据类型 (Data Types) 5.3 数学表达和运算 5.4 逻辑 5.5 判断和循环（控制流程） 5.6 函数 5.7 简易的统计学计算", " Chapter 5 向量，逻辑，循环和函数 注意，R中的变量名/自定义函数名不能以数字和特殊符号开头，中间只能使用&quot;_“和”.&quot;作为特殊符号3 5.1 向量的概念，操作和优越性 R没有标量，它通过各种类型的向量 (vector)来存储数据。 5.1.1 创建向量（赋值） 与很多其他的计算机语言不同，在R中，&lt;-（像一个小箭头）用于给向量，数据框和函数赋值（即在每行的开头）。在RStudio中，可以用Alt+- (Mac是 option+-) 这个快捷键打出这个符号。 x &lt;- 2 x ## [1] 2 虽然=也可以用，但是绝大多数R用户还是采用标准的&lt;-符号，而=则用于给函数的参数赋值。 要创建一个多元素的向量，需要用到c() (concatenate)函数： nums &lt;- c(1,45,78) cities &lt;- c(&quot;Zürich&quot;, &quot;上海&quot;, &quot;Tehrān&quot;) nums ## [1] 1 45 78 cities ## [1] &quot;Zürich&quot; &quot;上海&quot; &quot;Tehrān&quot; 通过length()函数，可以查看向量的长度。 length(nums) ## [1] 3 #如果无后续使用，没必要赋值一个变量；c(...)的计算结果就是一个向量，并直接传给`length()`函数 length(c(&quot;Guten Morgen&quot;)) ## [1] 1 （每个被引号包围的一串字符，都只算做一个元素，因此长度为1；多元素的向量请看第5.1.1节） 5.1.2 索引 索引 (index)就是一个元素在向量中的位置。R是从1开始索引的，即索引为1的元素是第一个元素（因此用熟了Python和C可能会有些不适应）。在向量后方使用方括号进行索引。 x &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;) x[3] ## [1] &quot;three&quot; 可以在方括号中使用另一个向量抓取多个元素： x[c(2,5,9)] # 第2个，第5个，第9个元素 ## [1] &quot;two&quot; &quot;five&quot; &quot;nine&quot; 经常，我们会抓取几个连续的元素。如果想知道方法，请继续往下看。 5.1.3 生成器 有时候我们需要其元素按一定规律排列的向量，这时，相对于一个个手动输入，有更方便的方法： 5.1.3.1 连续整数 1:10 #从左边的数（包含）到右边的数（包含），即1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 这时，你应该会有个大胆的想法： x[3:6] ## [1] &quot;three&quot; &quot;four&quot; &quot;five&quot; &quot;six&quot; 没错就是这么用的，而且极为常用。 当元素比较多的时候： y &lt;- 7:103 #复习一下赋值 y ## [1] 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ## [18] 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 ## [35] 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 ## [52] 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 ## [69] 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 ## [86] 92 93 94 95 96 97 98 99 100 101 102 103 注意到了左边方括号中的数字了吗？它们正是所对应的那一行第一个元素的索引。 下面的内容可能有点偏，可以酌情从这里跳到第5.1.5节。 5.1.3.2 复读机rep() rep(c(0, 7, 6, 0), 4) # 把[0, 7, 6, 0]重复4遍 ## [1] 0 7 6 0 0 7 6 0 0 7 6 0 0 7 6 0 5.1.3.3 等差数列: seq() 公差确定时： seq(0, 15, 2.5) # 其实是`seq(from = 0, to = 50, by = 5)`的简写 ## [1] 0.0 2.5 5.0 7.5 10.0 12.5 15.0 长度确定时： seq(0, 50, length.out = 11) # 其实是`seq(from = 0, to = 50, length.out = 11)`的简写 ## [1] 0 5 10 15 20 25 30 35 40 45 50 5.1.3.4 随机数： 连续型均匀分布随机数用runif(n, min, max)，n是数量，min是最小值，max是最大值。默认min为0，max为1。 x_unif &lt;- runif(100000, 40, 60) # 生成100000个40到60之间，连续均匀分布的的随机数 hist(x_unif) # 画直方图 正态分布随机数用rnorm(n, mean, sd), 三个参数分别为数量，平均值，标准差。默认mean为0，sd为1。 x_norm &lt;- rnorm(100000, 250, 20) # 按照平均值为250，标准差为20的正态分布的概率密度函数生成100000个随机数 hist(x_norm) # 画直方图 5.1.4 向量的其它操作 5.1.4.1 sort(), rank()和order() 5.1.5 R向量的优越性 R中的向量（矩阵和数列也是）的各种计算默认都是逐元素 (elementwise)的。比如： x &lt;- c(4, 9, 25) y &lt;- c(8, 6, 3) x + y ## [1] 12 15 28 x * y # 在matlab中这样乘是不行的，要用`.*`，除法也是 ## [1] 32 54 75 sqrt(x) ## [1] 2 3 5 相比于常用的编程语言，省去了for循环；相比于matlab的默认矩阵乘法，逐元素乘法在数据处理中更有用。 5.2 数据类型 (Data Types) 向量所存储的的数据类型有： 类型 含义与说明 例子 numeric 浮点数向量 3, 0.5, sqrt(2), NaN, Inf integer 整数向量 3L, 100L character 字符向量；需被引号包围 &quot;1&quot;, &quot;$&quot;, &quot;你好&quot; logical 逻辑向量 TRUE, FALSE, NA complex 复数向量 3+5i, 1i, 1+0i 通过class()函数，可以查看向量的类型。 class(&quot;早上好&quot;) ## [1] &quot;character&quot; （除此之外，typeof(), mode(), storage.mode()这三个函数的功能与class()类似，但有重要的区别；为避免造成困惑，此处不展开讨论）。 5.3 数学表达和运算 5.3.1 数的表达 5.3.1.1 浮点数 除非指定作为整数（见下），在R中所有的数都被存储为双精度浮点数的格式 (double-precision floating-point format)，其class为numeric。 class(3) ## [1] &quot;numeric&quot; 这会导致一些有趣的现象，比如\\((\\sqrt{3})^2 \\neq 3\\)：（强迫症患者浑身难受） sqrt(3)^2-3 ## [1] -4.440892e-16 浮点数的计算比精确数的计算快很多。如果你是第一次接触浮点数，可能会觉得它不可靠，其实不然。在绝大多数情况下，牺牲的这一点点精度并不会影响计算结果（我们的结果所需要的有效数字一般不会超过10位；只有当两个非常，非常大且数值相近对数字相减才会出现较大的误差）。 NaN（非数）和Inf（无限大）也是浮点数！ class(NaN) ## [1] &quot;numeric&quot; class(Inf) ## [1] &quot;numeric&quot; 5.3.1.2 科学计数法 在R中可以使用科学计数法(AeB\\(= A \\times 10^B\\))，比如： 3.1e5 ## [1] 310000 -1.2e-4+1.1e-5 ## [1] -0.000109 5.3.1.3 整数 整数的class为integer。有两种常见的方法创建整数： 1）在数后面加上L； class(2) ## [1] &quot;numeric&quot; class(2L) ## [1] &quot;integer&quot; 2）创建数列 1:10 #公差为1的整数向量生成器，包含最小值和最大值 ## [1] 1 2 3 4 5 6 7 8 9 10 class(1:10) ## [1] &quot;integer&quot; seq(5,50,5) #自定义公差，首项，末项和公差可以不为整数 ## [1] 5 10 15 20 25 30 35 40 45 50 class(seq(5,50,5)) #因此产生的是一个浮点数向量 ## [1] &quot;numeric&quot; seq(5L,50L,5L) #可以强制生成整数 ## [1] 5 10 15 20 25 30 35 40 45 50 class(seq(5L,50L,5L)) #是�整数没错 ## [1] &quot;integer&quot; 整数最常见的用处是indexing（索引）。 5.3.1.3.1 整数变成浮点数的情况 这一小段讲的比较细，请酌情直接跳到下一节（5.3.2）。 整数与整数之前的加，减，乘，求整数商，和求余数计算会得到整数，其他的运算都会得到浮点数，（阶乘(factorial)也是，即便现实中不管怎么阶乘都不可能得到非整数）： class(2L+1L) ## [1] &quot;integer&quot; class(2L-1L) ## [1] &quot;integer&quot; class(2L*3L) ## [1] &quot;integer&quot; class(17L%/%3L) ## [1] &quot;integer&quot; class(17L%%3L) ## [1] &quot;integer&quot; class(1000L/1L) ## [1] &quot;numeric&quot; class(3L^4L) ## [1] &quot;numeric&quot; class(sqrt(4L)) ## [1] &quot;numeric&quot; class(log(exp(5L))) ## [1] &quot;numeric&quot; class(factorial(5L)) ## [1] &quot;numeric&quot; 整数与浮点数之间的运算，显然，全部都会产生浮点数结果，无需举例。 另外一个需要注意的地方是，取整函数5.3.2.3并不会产生整数。如果需要的话，要用as.integer()函数。 5.3.2 运算 5.3.2.1 二元运算符号 R中的binary operators（二元运算符）有： 符号 描述 + 加 - 减 * 乘 / 除以 ^或** 乘幂 %/% 求整数商，比如7%%3\\(=2\\) %% 求余数，比如7%%3\\(=1\\) 其中求余/求整数商最常见的两个用法是判定一个数的奇偶性，和时间，角度等单位的转换。（后面再详细介绍）。 5.3.2.2 \\(e^x\\)和\\(\\log_x{y}\\) exp(x)便是运算\\(e^x\\)。如果想要\\(e=2.71828...\\)这个数： exp(1) ## [1] 2.718282 log(x, base=y)便是运算\\(\\log_y{x}\\)，可以简写成log(x,y)（简写需要注意前后顺序，第5.6.1有解释）。 默认底数为\\(e\\)： log(exp(5)) ## [1] 5 有以10和2为底的快捷函数, log10()和log2() log10(1000) ## [1] 3 log2(128) ## [1] 7 5.3.2.3 近似数（取整，取小数位，取有效数字） 注意，取整函数给出的的结果不是整数！ class(ceiling(7.4)) ## [1] &quot;numeric&quot; 5.3.2.4 R中自带的数学函数集合 函数 描述 exp(x) \\(e^x\\) log(x,y) \\(\\log_yx\\) log(x) \\(\\ln(x)\\) sqrt(x) \\(\\sqrt{x}\\) factorial(x) \\(x!=x\\times(x-1)\\times(x-2)\\ldots\\times2\\times1\\) choose(n,k) \\(\\binom{n}{k}=\\frac{n!}{k!(n-k)!}\\)（二项式系数） gamma(z) \\(\\Gamma(z)=\\int_0^\\infty x^{z-1}e^{-x}dx\\)（伽马函数） lgamma(z) \\(\\ln(\\Gamma(z))\\) floor(x), ceiling(x), trunc(x), 取整；见上一小节。 round(x, digits = n) 四舍五入，保留n个小数位，n默认为0 signif(x,digits = n) 四舍五入，保留n个有效数字，n默认为6） sin(x), cos(x), tan(x) 三角函数 asin(x), acos(x), atan(x) 反三角函数 sinh(x), cosh(x), tanh(x) 双曲函数 abs(x) \\(|x|\\)（取绝对值） 5.4 逻辑 5.4.1 Logical Values（逻辑值） 逻辑值有三个。TRUE, FALSE和NA. class(c(TRUE,FALSE,NA)) ## [1] &quot;logical&quot; TRUE为真，FALSE为假，NA为未知（即真假难辨）。 5.4.2 Logical Operations（逻辑运算） R中常用的关系运算符有： 符号 描述 == equal to（等于） != equal to（不等于） &lt; less than（小于） &gt; more than（大于） &lt;= less than or equal to（小于等于） &gt;= more than or equal to（大于等于） 使用关系运算符进行计算，会产生逻辑值作为结果。比如： x &lt;- 5 x != 3 #x等于5，所以“x不等于3”为真 ## [1] TRUE 有一些其他的运算符或函数也会返回逻辑值，比如 7 %in% c(1,4,5,6,7) ## [1] TRUE 顾名思义，这个运算符是用来检测一个元素是否在另一个向量中。其它类型的运算符，我在需要用到的时候再讲。 5.4.3 逻辑运算详解 5.4.3.1 逻辑运算符 以下是最常用的三个逻辑运算符。 符号 描述 &amp; AND（且） | OR（或） ! 反义符号 5.4.3.2 反义符号（!） !使TRUE FALSE颠倒。一般，我们用小括号来包住一个逻辑运算，然后在它的前面加上一个!来反转结果，比如 !(3 &lt; 4) # 这个例子很简单，反义符号意义不大。后面实操的时候才能领略到它的用处。 ## [1] FALSE 5.4.3.3 多个逻辑运算的组合（&amp;（且）和|（或）） &amp;和|可以把多个逻辑运算的结果合并成一个逻辑值。 &amp;判断是否两边运算结果都为TRUE。如果是，才会得到TRUE（即一真和一假得到假）。（正统的翻译貌似是“与”，但是我觉得不太与中文语法适配；想想“\\(x\\)大于\\(2\\)与\\(y\\)小于\\(4\\)”是不是比“\\(x\\)大于\\(2\\)且\\(y\\)小于\\(4\\)”别扭） |判断两边运算结果是否至少有一个 TRUE，如果是，就会得到TRUE。 不用死记硬背！其实就是“且”和“或”的逻辑。 用脑子想一下以下三条运算的结果，然后复制代码到R console对答案。 1 == 1 &amp; 1 == 2 &amp; 3 == 3 #即：“1等于1且1等于2且3等于3”，是真还是假？ FALSE | FALSE | TRUE # FALSE/TRUE等价于一个运算结果 !(FALSE | TRUE) &amp; TRUE # 注意反义符号 我们可以查看三个逻辑值所有两两通过&amp;组和的计算结果（如果你不感兴趣，可以不看方法。这里重点是结果）： vals &lt;- c(TRUE, FALSE, NA) names(vals) &lt;- paste(&#39;[&#39;,as.character(vals),&#39;]&#39;,sep = &#39;&#39;) outer(vals, vals, &quot;&amp;&quot;) ## [TRUE] [FALSE] [NA] ## [TRUE] TRUE FALSE NA ## [FALSE] FALSE FALSE FALSE ## [NA] NA FALSE NA 可以看到，FALSE与任何逻辑值组合，结果都是FALSE。这个好理解，因为一旦一个是FALSE，那么不可能两边都是TRUE. TRUE &amp; NA之所以为NA（而不是FALSE），是因为NA的意思是“不能确定真假”，即有可能真也有可能假。因此TRUE &amp; NA也无法辨真假。 再来看|的组合： outer(vals, vals, &quot;|&quot;) ## [TRUE] [FALSE] [NA] ## [TRUE] TRUE TRUE TRUE ## [FALSE] TRUE FALSE NA ## [NA] TRUE NA NA 可以看到，TRUE与任何一个逻辑值组合，都是TRUE，而FALSE | NA为NA。原因一样（因为NA的不确定性）。 5.5 判断和循环（控制流程） 如果你学过其他编程语言，知道判断和循环的作用，只是需要知道在R中的表达，那么请看以下两个例子快速入门，然后跳过本节（如果没学过，请往后面看）： foo &lt;- 1:100 #产生一个[1,2,3,...,99,100]的整数向量。上面讲过。 bar &lt;- vector(&quot;numeric&quot;) for (i in foo) { if (i %% 2 == 0) { bar &lt;- append(bar, i^2) } else if (i == 51) { break } } bar ## [1] 4 16 36 64 100 144 196 256 324 400 484 576 676 784 ## [15] 900 1024 1156 1296 1444 1600 1764 1936 2116 2304 2500 logi = TRUE num &lt;- 1 while (num &lt;= 100) { if (logi) { num = num + 10 # R 不支持 num += 5的简写 print(num) logi = FALSE } else { num = num + 20 print(num) logi = TRUE } } ## [1] 11 ## [1] 31 ## [1] 41 ## [1] 61 ## [1] 71 ## [1] 91 ## [1] 101 5.5.1 if, else, else if 语句 if语句长这样： if (something is true/false) { do something } 其中小括号内为测试的条件，其运算结果需为TRUE或FALSE（关于逻辑值的计算请看第5.4节。若运算结果为TRUE，大括号内的语句将会被执行。 注意，不能直接用x == NA来判断是否是NA，而要用is.na(x) R中没有专门的elseif语句，但用else加上if能实现同样的效果。 5.6 函数 不像很多其他语言的函数有value.func()和func value等格式，R中所有函数的通用格式是这样的： function(argument1=value1, argument2=value2, ...) 比如 x1 &lt;- c(5.1,5.2,4.5,5.3,4.3,5.5,5.7) t.test(x=x1, mu = 4.5) ## ## One Sample t-test ## ## data: x1 ## t = 3.0308, df = 6, p-value = 0.02307 ## alternative hypothesis: true mean is not equal to 4.5 ## 95 percent confidence interval: ## 4.612840 5.558589 ## sample estimates: ## mean of x ## 5.085714 （英语中，“parameter”或“formal argument”二词用于函数定义，“argument”或“actual argument”二词用于调用函数(Kernighan and Ritchie 1988)，中文里分别是“形式参数”和“实际参数”，但是多数场合简称“参数”。） 5.6.1 调用函数时的简写 以seq函数为例，通过查看documentation（在console执行?seq）可以查看它的所有的参数： ## Default S3 method: seq(from = 1, to = 1, by = ((to - from)/(length.out - 1)), length.out = NULL, along.with = NULL, ...) 可以看到第一个参数是from，第二个是to，第三个是by，以此类推。因此我们执行seq(0, 50, 10)的时候，R会自动理解成seq(from = 0, to = 50, by = 10)。而想用指定长度的方法就必须要写清楚是length.out等于几。 length.out本身也可以简写： seq(0, 25, l = 11) ## [1] 0.0 2.5 5.0 7.5 10.0 12.5 15.0 17.5 20.0 22.5 25.0 因为参数中只有length.out是以l开头的，l会被理解为length.out. 但是这个习惯并不好；自己用用就算了，与别人分享自己的工作时请务必使用标准写法。 5.6.2 关于... 有时候，你想写的函数可能有数量不定的参数，或是有需要传递给另一个函数的“其它参数”（即本函数不需要的参数），这时候可以在函数定义时加入一个名为...的参数，然后用list()来读取它们。list是进阶内容，在第??节有说明。 比如我写一个很无聊的函数： my_func &lt;- function(arg1, arg2 = 100, ...){ other_args &lt;- list(...) print(arg1) print(arg2) print(other_args) } my_func(&quot;foo&quot;, cities = c(&quot;崇阳&quot;, &quot;Αθήνα&quot;, &quot;つがる&quot;), nums = c(3,4,6)) ## [1] &quot;foo&quot; ## [1] 100 ## $cities ## [1] &quot;崇阳&quot; &quot;Αθήνα&quot; &quot;つがる&quot; ## ## $nums ## [1] 3 4 6 arg1指定了是&quot;foo&quot;（通过简写），因此第一行印出&quot;foo&quot;; arg2未指定，因此使用默认值100，印在第二行。cities和nums在形式参数中没有匹配，因此归为“…”，作为list印在第三行及之后。 5.7 简易的统计学计算 5.7.1 t分布 众所周知，t分布长这样： 阴影面积为\\(P(t&lt;T)\\)，虚线对应的\\(t\\)为\\(T\\). qt()可以把\\(P(t≤T)\\)的值转化成\\(T\\),pt()则相反。 假设你需要算一个confidence interval（置信区间），confidence level（置信等级）为\\(95\\%\\)，即\\(\\alpha=0.05\\)，degrees of freedom(自由度)为\\(12\\)，那么怎么算\\(t^*\\)呢？ qt(0.975, df = 12) ## [1] 2.178813 为什么是\\(0.975\\)？因为你要把\\(0.05\\)分到左右两边，所对应的t*就等同于t分布中，\\(P(t ≤ T) = 0.975\\)时T的值。 再举一个例子，你在做t检验，双尾的，算出来\\(t=1.345\\)，自由度是\\(15\\)，那么\\(p\\)值怎么算呢？ p &lt;- (1-(pt(2.2, df = 15)))*2 p ## [1] 0.04389558 其中pt(2.2, df = 15)算出阴影面积（\\(P(t≤T)\\)的值），1减去它再乘以2就是对应的双尾t检验的\\(p\\)值。 5.7.2 z分布 没有z分布专门的函数。可以直接用t分布代替，把df调到很大（比如999999）就行了。比如我们试一下\\(95\\%\\)置信区间所对应的\\(z*\\)： qt(0.975,9999999) ## [1] 1.959964 （果然是\\(1.96\\)） 5.7.3 t检验 t检验分为以下几种： One sample t test （单样本） paired t test（配对） Two sample…（双样本） Unequal variance t test（不等方差） Equal variance t test（等方差） 在R中做t检验，很简单，以上这些t检验，都是用t.test 这个函数去完成。 以单样本为例： x &lt;- c(2.23,2.24,2.34,2.31,2.35,2.27,2.29,2.26,2.25,2.21,2.29,2.34,2.32) t.test(x, mu = 2.31) ## ## One Sample t-test ## ## data: x ## t = -2.0083, df = 12, p-value = 0.06766 ## alternative hypothesis: true mean is not equal to 2.31 ## 95 percent confidence interval: ## 2.257076 2.312155 ## sample estimates: ## mean of x ## 2.284615 可以看到\\(p=0.06766\\)。 R的默认是双尾检验，你也可以设置成单尾的： x &lt;- c(2.23,2.24,2.34,2.31,2.35,2.27,2.29,2.26,2.25,2.21,2.29,2.34,2.32) t.test(x, mu = 2.31, alternative = &quot;less&quot;) # 检验是否*less* than μ ## ## One Sample t-test ## ## data: x ## t = -2.0083, df = 12, p-value = 0.03383 ## alternative hypothesis: true mean is less than 2.31 ## 95 percent confidence interval: ## -Inf 2.307143 ## sample estimates: ## mean of x ## 2.284615 \\(p\\)值瞬间减半。 双样本/配对: x &lt;- c(2.23,2.24,2.34,2.31,2.35,2.27,2.29,2.26,2.25,2.21,2.29,2.34,2.32) y &lt;- c(2.27,2.29,2.37,2.38,2.39,2.25,2.39,2.16,2.55,2.81,2.19,2.44,2.22) t.test(x, y) ## ## Welch Two Sample t-test ## ## data: x and y ## t = -1.5624, df = 13.65, p-value = 0.1411 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -0.18460351 0.02921889 ## sample estimates: ## mean of x mean of y ## 2.284615 2.362308 R的默认是non-paired, unequal variance，你可以通过增加paired = TRUE，var.equal = TRUE这两个参数来改变它。 t.test(x, y, paired = TRUE) ## ## Paired t-test ## ## data: x and y ## t = -1.4739, df = 12, p-value = 0.1662 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -0.19253874 0.03715412 ## sample estimates: ## mean of the differences ## -0.07769231 5.7.4 \\(\\chi^2\\) 检验 彩蛋：用R代码实现卡方分布的概率密度函数的图像： #其实还可以更精简，但是为了易读性不得不牺牲一点精简度。 Z &lt;- matrix(rep(rnorm(1000000), 6), nrow = 6)^2 X &lt;- Z^2 Q &lt;- matrix(nrow = 6, ncol = 1000000) for (i in (1+1):6) { Q[1,] = Z[1,] Q[i,] = Q[(i-1),] + Z[i,] } plot(NULL, xlim=c(0.23,6), ylim = c(0,1), main = expression(paste(&#39;X ~ &#39;, chi^&#39;2&#39;, &#39;(k)&#39;)), xlab = &quot;x&quot;, ylab= expression(f[k]*&#39;(x)&#39;) ) colors &lt;- c(&#39;blue&#39;, &#39;black&#39;, &#39;red&#39;, &#39;green&#39;, &#39;gray&#39;, &#39;orange&#39;) for (i in 1:6) { lines(density(Q[i,]), col=colors[i], lwd=2) } legend(&#39;topright&#39;,c(&#39;k=1&#39;,&#39;k=2&#39;,&#39;k=3&#39;,&#39;k=4&#39;,&#39;k=5&#39;,&#39;k=6&#39;), fill = colors) \\(\\chi^2\\)检验有两种，goodness of fit Bibiolography "],
["ch5.html", "Chapter 6 dataframe（数据框）和tibble 6.1 查看dataframe/tibble并了解它们的结构 6.2 tibble的创建和基础操作 6.3 进阶内容", " Chapter 6 dataframe（数据框）和tibble 6.1 查看dataframe/tibble并了解它们的结构 6.1.1 dataframe/tibble的基本概念 dataframe是R中存储复杂数据的格式，它直观易操作。tibble是tidyverse的一部分，它是dataframe的进化版，功能更强大，更易操作。 我们来看个例子： 首先加载tidyverse： require(tidyverse) 以后每次跟着本书使用R的时候，都要先加载tidyverse，不再重复提醒了。 tidyverse中自带一些范例数据，比如我们输入： mpg 这张图是重中之重。一个正确的dataframe/tibble，每一行代表的是一个observation（硬翻译的话是“观测单位”，但是我觉得这个翻译不好），每一列代表的是一个variable（变量），且同一个变量的数据类型必须一样4。像这样的数据被称为“tidy data”（“整齐的数据”）。虽然看起来简单，直观，理所当然，但是现实中上人们经常会做出“不整齐”的数据。把不整齐的数据弄整齐是下一章的重点。 6.1.2 查看更多数据 R默认显示dataframe/tibble的前10行。如果想看最后6行，可以使用tail()函数，比如： tail(mpg) ## # A tibble: 6 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 volkswagen passat 1.8 1999 4 auto… f 18 29 p mids… ## 2 volkswagen passat 2 2008 4 auto… f 19 28 p mids… ## 3 volkswagen passat 2 2008 4 manu… f 21 29 p mids… ## 4 volkswagen passat 2.8 1999 6 auto… f 16 26 p mids… ## 5 volkswagen passat 2.8 1999 6 manu… f 18 26 p mids… ## 6 volkswagen passat 3.6 2008 6 auto… f 17 26 p mids… 若要从头到尾查看全部数据，可以使用View函数： View(mpg) 6.2 tibble的创建和基础操作 6.2.1 创建tibble 6.2.1.1 手动输入数据以创建tibble 使用tibble函数，按以下格式创建tibble. 换行不是必须的，但是换行会看得更清楚。如果换行，不要忘记行末的逗号。 my_tibble_1 &lt;- tibble( nums = c(4, 5, 6), chars = c(&quot;hej&quot;, &quot;你好&quot;, &quot;こんにちは&quot;), cplxnums = c(&quot;4+8i&quot;, &quot;3+5i&quot;, &quot;3+4i&quot;) ) my_tibble_1 ## # A tibble: 3 x 3 ## nums chars cplxnums ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 4 hej 4+8i ## 2 5 你好 3+5i ## 3 6 こんにちは 3+4i 类似地，可以从现有的vector创建。所有的变量长度必须一样。 x &lt;- c(1,4,5) y &lt;- c(211,23,45) z &lt;- c(20,32) my_tibble_2 &lt;- tibble(v1 = x, v2 = y) my_tibble_2 ## # A tibble: 3 x 2 ## v1 v2 ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 211 ## 2 4 23 ## 3 5 45 而试图把x和z做成tibble就会报错： my_tibble_3 &lt;- tibble(w1 = x, w2 = z) # Error: Tibble columns must have consistent lengths, only values of length one are recycled: * Length 2: Column `w2` * Length 3: Column `w1` 6.2.1.2 把dataframe转换成一个tibble d1 &lt;- as.tibble(d) #其中d是一个dataframe 6.2.1.3 从外部数据创建tibble 参见第8.2.1节（数据的导入） 6.2.2 抓取行，列 6.2.2.1 抓取单列 抓取单列很简单，也很常用（比如我们只想从一个大的tibble中抓两个变量研究它们之间的关系）。 有两个符号可以用于抓取列，$（仅用于变量名称）与[[]]（变量名称或索引）。还是以mpg为例，假设我们要抓取第3列 (displ)： ######################## #通过变量名称抓取： mpg[[&quot;displ&quot;]] #或 mpg$displ #一般，在RStudio中此方法最方便，因为打出“$”之后会自动提示变量名。 ######################## #通过索引抓取： mpg[[3]] 以上三种方法都应得到同样的结果（是一个vector）： ## [1] 1.8 1.8 2.0 2.0 2.8 2.8 3.1 1.8 1.8 2.0 2.0 2.8 2.8 3.1 3.1 2.8 3.1 ## [18] 4.2 5.3 5.3 6.2.2.2 抓取多列 有时候，一个tibble中含有很多冗余信息，我们可能想把感兴趣的几个变量抓出来做一个新tibble. 这时select()函数最为方便。可以用变量名称或者索引来抓取。比如： mpg_new &lt;- select(mpg, 3:5, 8, 9) #等同于 mpg_new &lt;- select(mpg, displ, year, cyl, cty, hwy) mpg_new ## # A tibble: 234 x 5 ## displ year cyl cty hwy ## &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1.8 1999 4 18 29 ## 2 1.8 1999 4 21 29 ## 3 2 2008 4 20 31 ## 4 2 2008 4 21 30 ## 5 2.8 1999 6 16 26 ## 6 2.8 1999 6 18 26 ## 7 3.1 2008 6 18 27 ## 8 1.8 1999 4 18 26 ## 9 1.8 1999 4 16 25 ## 10 2 2008 4 20 28 ## # … with 224 more rows 6.2.2.3 通过filter()，抓取满足某条件的行 通过filter()，我们可以过滤出某个或多个变量满足某种条件的observations. 如果你还不熟悉逻辑运算，请看第5.4.2节 假设我们只想看mpg中的奥迪品牌的，排量大于等于2且小于4的车辆的数据： mpg_audi_displ2to4 &lt;- filter(mpg, manufacturer == &quot;audi&quot;, displ &gt;= 2.5 &amp; displ &lt; 4) mpg_audi_displ2to4 ## # A tibble: 9 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 2.8 1999 6 auto… f 16 26 p comp… ## 2 audi a4 2.8 1999 6 manu… f 18 26 p comp… ## 3 audi a4 3.1 2008 6 auto… f 18 27 p comp… ## 4 audi a4 qu… 2.8 1999 6 auto… 4 15 25 p comp… ## 5 audi a4 qu… 2.8 1999 6 manu… 4 17 25 p comp… ## 6 audi a4 qu… 3.1 2008 6 auto… 4 17 25 p comp… ## 7 audi a4 qu… 3.1 2008 6 manu… 4 15 25 p comp… ## 8 audi a6 qu… 2.8 1999 6 auto… 4 15 24 p mids… ## 9 audi a6 qu… 3.1 2008 6 auto… 4 17 25 p mids… 6.2.2.4 用slice()，通过行数（索引）抓取行。 mpg_1to6 &lt;- slice(mpg, 21:26) # 抓取mpg的第21行至26行 mpg_1to6 ## # A tibble: 6 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 chevrolet c1500… 5.3 2008 8 auto… r 14 20 r suv ## 2 chevrolet c1500… 5.7 1999 8 auto… r 13 17 r suv ## 3 chevrolet c1500… 6 2008 8 auto… r 12 17 r suv ## 4 chevrolet corve… 5.7 1999 8 manu… r 16 26 p 2sea… ## 5 chevrolet corve… 5.7 1999 8 auto… r 15 23 p 2sea… ## 6 chevrolet corve… 6.2 2008 8 manu… r 16 26 p 2sea… 我觉得slice()更实际的用途是随机选择个体： mpg_random4 &lt;- slice(mpg, sample(length(mpg[[1]]), 4)) # 随机四辆车 mpg_random4 ## # A tibble: 4 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 qu… 1.8 1999 4 auto… 4 16 25 p comp… ## 2 nissan pathf… 4 2008 6 auto… 4 14 20 p suv ## 3 ford f150 … 4.6 1999 8 auto… 4 13 16 r pick… ## 4 volkswagen gti 2.8 1999 6 manu… f 17 24 r comp… 6.2.3 关于Factor 有时候，我们的变量是以文字的形式呈现，但是它们不是单纯的文字，而是有大小的差别，或是能以一定顺序排列，比如十二个月份 (Jan, Feb, …)，成绩的“优、良、中、差”，衣服的尺寸 (XS, S, M, XL, …). 假设我们在做客户满意度调查，七位客户的反馈是 满意度_v &lt;- c(&quot;满意&quot;, &quot;非常满意&quot;, &quot;满意&quot;, &quot;不满意&quot;, &quot;满意&quot;, &quot;非常不满&quot;, &quot;不满意&quot;) 我们试图用sort()把七个反馈按满意度从小到大排列： sort(满意度_v) ## [1] &quot;不满意&quot; &quot;不满意&quot; &quot;满意&quot; &quot;满意&quot; &quot;满意&quot; &quot;非常不满&quot; ## [7] &quot;非常满意&quot; 可见其排序并不是有意义的。（因为默认英语根据’abcde…’排序，中文根据笔画排序） 我们可以把这个vector做成factor，并用参数levels规定排序顺序： # 按照惯例，小的值在前，大的在后；“非常不满”应为满意度最低的值。 满意度_f &lt;- factor(满意度_v, levels = c(&quot;非常不满&quot;, &quot;不满意&quot;, &quot;满意&quot;, &quot;非常满意&quot;)) sort(满意度_f) ## [1] 非常不满 不满意 不满意 满意 满意 满意 非常满意 ## Levels: 非常不满 不满意 满意 非常满意 这样排序就是正确的了。 class(满意度_f) # &quot;factor&quot; is.vector(满意度_f) # FALSE 6.3 进阶内容 这一节为进阶内容，不用看。可以直接跳到下一章（第7 其中的很多操作和dataframe或tibble中的操作是等效的。一般，tibble中的操作更直观，更容易上手。 6.3.1 arrays（数组）和matrices（矩阵）简介 Vector是一维的数据。Array是多维的数据。Matrix是二维的数据，因此matrix是array的一种特殊情况。 Dataframe不是matrix. A matrix is a two-dimensional array containing numbers. A dataframe is a two-dimensional list containing (potentially a mix of) numbers, text or logical variables in different columns. 我们可以用dim()来创建arrays： A &lt;- 1:48 #创建一个(1,2,3,...24)的numeric vector dim(A) &lt;- c(6,8) #给A assign一个6乘4的dimensions A ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] 1 7 13 19 25 31 37 43 ## [2,] 2 8 14 20 26 32 38 44 ## [3,] 3 9 15 21 27 33 39 45 ## [4,] 4 10 16 22 28 34 40 46 ## [5,] 5 11 17 23 29 35 41 47 ## [6,] 6 12 18 24 30 36 42 48 可以看到我们创建了一个二维的，array, 因此它也是一个（4行6列的）matrix。 is.array(A) ## [1] TRUE is.matrix(A) ## [1] TRUE 注意24个数字排列的方式。第一个维度是行，所以先把4行排满，随后再使用下一个维度（列），使用第2列继续排4行，就像数字一样，（十进制中）先把个位从零数到9，再使用第二个位数（十位），以此类推。下面三维和四维的例子可能会更清晰。 同时注意最左边和最上边的[1,], [,3]之类的标记。你应该猜出来了，这些是index. 假设你要抓取第五行第三列的数值： A[5,3] ## [1] 17 或者第三行的全部数值： A[3,] ## [1] 3 9 15 21 27 33 39 45 或者第四列的全部数值： A[,4] ## [1] 19 20 21 22 23 24 接下来我们再看一个三维的例子（还是用1-48）： dim(A) &lt;- c(2,8,3) A ## , , 1 ## ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] 1 3 5 7 9 11 13 15 ## [2,] 2 4 6 8 10 12 14 16 ## ## , , 2 ## ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] 17 19 21 23 25 27 29 31 ## [2,] 18 20 22 24 26 28 30 32 ## ## , , 3 ## ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] 33 35 37 39 41 43 45 47 ## [2,] 34 36 38 40 42 44 46 48 它生成了三个二维的矩阵。在每个2*8的矩阵存储满16个元素后，第三个维度就要加一了。每个矩阵开头的, , x正是第三个维度的值。同理，我们可以生成四维的array： dim(A) &lt;- c(3,4,2,2) A ## , , 1, 1 ## ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 ## ## , , 2, 1 ## ## [,1] [,2] [,3] [,4] ## [1,] 13 16 19 22 ## [2,] 14 17 20 23 ## [3,] 15 18 21 24 ## ## , , 1, 2 ## ## [,1] [,2] [,3] [,4] ## [1,] 25 28 31 34 ## [2,] 26 29 32 35 ## [3,] 27 30 33 36 ## ## , , 2, 2 ## ## [,1] [,2] [,3] [,4] ## [1,] 37 40 43 46 ## [2,] 38 41 44 47 ## [3,] 39 42 45 48 观察每个矩阵开头的, , x, y. x是第三个维度，y是第四个维度。每个二位矩阵存满后，第三个维度（x）加一。x达到上限后，第四个维度（y）再加一。 类似二维矩阵，你可以通过index任意抓取数据，比如： A[ ,3 , , ] #每个矩阵第3列的数据，即所有第二个维度为3的数值 ## , , 1 ## ## [,1] [,2] ## [1,] 7 19 ## [2,] 8 20 ## [3,] 9 21 ## ## , , 2 ## ## [,1] [,2] ## [1,] 31 43 ## [2,] 32 44 ## [3,] 33 45 6.3.2 给matrices和arrays命名 假设我们记录了3种药物（chloroquine, artemisinin, doxycycline) 对5种疟原虫(P. falciparum, P. malariae, P. ovale, P. vivax, P. knowlesi)的疗效，其中每个药物对每种疟原虫做6次实验。为了记录数据，我们可以做3个6*5的矩阵：（这里只是举例子，用的是随机生成的数字） B &lt;- runif(90, 0, 1) #从均匀分布中取100个0到1之间的数 dim(B) &lt;- c(6, 5, 3) #注意顺序 B ## , , 1 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0.4950958 0.7033751 0.04165442 0.20239886 0.41653277 ## [2,] 0.2118592 0.5563241 0.74051328 0.03337075 0.57681032 ## [3,] 0.5022548 0.8836259 0.25022338 0.22861115 0.84502002 ## [4,] 0.5812348 0.3845606 0.01002410 0.80672837 0.46923669 ## [5,] 0.3569207 0.4303088 0.55884189 0.01950840 0.16256741 ## [6,] 0.7409004 0.3691681 0.67059087 0.99673816 0.04505479 ## ## , , 2 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0.1193267 0.58096138 9.362910e-01 0.740775275 0.2330679 ## [2,] 0.1936825 0.93822863 5.549355e-05 0.004512186 0.5937470 ## [3,] 0.9745862 0.97386515 7.628234e-01 0.764408651 0.4869162 ## [4,] 0.2060590 0.11214832 5.309767e-01 0.164678374 0.5803760 ## [5,] 0.6738190 0.03986242 9.207977e-01 0.068236070 0.4467812 ## [6,] 0.4685471 0.82054439 4.078008e-01 0.199580526 0.4050751 ## ## , , 3 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0.5151080 0.3459663 0.88731132 0.48407170 0.84812237 ## [2,] 0.5319477 0.7008972 0.69657258 0.36067119 0.17627486 ## [3,] 0.5948253 0.6883097 0.06057588 0.01579035 0.49753766 ## [4,] 0.5408423 0.8531697 0.84908461 0.16517355 0.50499935 ## [5,] 0.3032947 0.3377085 0.48720360 0.02857172 0.05187764 ## [6,] 0.4592401 0.1651308 0.93089103 0.94404232 0.49102795 然后我们用dimnames()来命名： dimnames(B) &lt;- list(paste(&quot;trial.&quot;, 1:6), c(&#39;P. falciparum&#39;, &#39;P. malariae&#39;, &#39;P. ovale&#39;, &#39;P. vivax&#39;, &#39;P. knowlesi&#39;), c(&#39;chloroquine&#39;, &#39;artemisinin&#39;, &#39;doxycycline&#39;)) B ## , , chloroquine ## ## P. falciparum P. malariae P. ovale P. vivax P. knowlesi ## trial. 1 0.4950958 0.7033751 0.04165442 0.20239886 0.41653277 ## trial. 2 0.2118592 0.5563241 0.74051328 0.03337075 0.57681032 ## trial. 3 0.5022548 0.8836259 0.25022338 0.22861115 0.84502002 ## trial. 4 0.5812348 0.3845606 0.01002410 0.80672837 0.46923669 ## trial. 5 0.3569207 0.4303088 0.55884189 0.01950840 0.16256741 ## trial. 6 0.7409004 0.3691681 0.67059087 0.99673816 0.04505479 ## ## , , artemisinin ## ## P. falciparum P. malariae P. ovale P. vivax P. knowlesi ## trial. 1 0.1193267 0.58096138 9.362910e-01 0.740775275 0.2330679 ## trial. 2 0.1936825 0.93822863 5.549355e-05 0.004512186 0.5937470 ## trial. 3 0.9745862 0.97386515 7.628234e-01 0.764408651 0.4869162 ## trial. 4 0.2060590 0.11214832 5.309767e-01 0.164678374 0.5803760 ## trial. 5 0.6738190 0.03986242 9.207977e-01 0.068236070 0.4467812 ## trial. 6 0.4685471 0.82054439 4.078008e-01 0.199580526 0.4050751 ## ## , , doxycycline ## ## P. falciparum P. malariae P. ovale P. vivax P. knowlesi ## trial. 1 0.5151080 0.3459663 0.88731132 0.48407170 0.84812237 ## trial. 2 0.5319477 0.7008972 0.69657258 0.36067119 0.17627486 ## trial. 3 0.5948253 0.6883097 0.06057588 0.01579035 0.49753766 ## trial. 4 0.5408423 0.8531697 0.84908461 0.16517355 0.50499935 ## trial. 5 0.3032947 0.3377085 0.48720360 0.02857172 0.05187764 ## trial. 6 0.4592401 0.1651308 0.93089103 0.94404232 0.49102795 清清楚楚，一目了然。 6.3.3 apply apply(A,1,sum) ## [1] 376 392 408 https://thomaswdinsmore.com/2014/12/15/sas-versus-r-part-two/↩ "],
["graphics.html", "Chapter 7 使用ggplot绘图 7.1 哲理 7.2 基础 7.3 进阶 7.4 附：Base R中的作图", " Chapter 7 使用ggplot绘图 若要了解更多，请阅读ggplot开发者本人所编写的ggplot2: Elegand Graphics for Data Analysis(Wickham 2015)。 7.1 哲理 7.2 基础 7.2.1 基本语法 7.2.2 图像类型 7.3 进阶 7.3.1 逐层作图 7.3.2 尺寸，轴，和图例 7.3.3 位置 7.3.4 背景/主题的修改 7.3.5 与ggplot编程 7.4 附：Base R中的作图 Bibiolography "],
["wrangle.html", "Chapter 8 数据处理 8.1 把“untidy data”整成“tidy data” 8.2 数据的导入和导出", " Chapter 8 数据处理 8.1 把“untidy data”整成“tidy data” 8.1.1 “untidy data”的主要问题 8.1.2 解决方案 8.2 数据的导入和导出 8.2.1 导入 8.2.1.1 csv 8.2.1.2 excel 8.2.1.3 其它 8.2.2 导出 "],
["python.html", "Chapter 9 与Python的联合使用 9.1 在R中使用Python: reticulate 9.2 在Python中使用R: rpy 9.3 Beaker Notebook", " Chapter 9 与Python的联合使用 9.1 在R中使用Python: reticulate 9.2 在Python中使用R: rpy 9.3 Beaker Notebook https://decisionstats.com/2015/12/07/decisionstats-interview-scott-draves-beaker-notebook/ Inspired by Jupyter, Beaker Notebook allows you to switch from one language in one code block to another language in another code block in a streamlined way to pass shared objects (data) "],
["bibiolography.html", "Bibiolography", " Bibiolography "]
]
